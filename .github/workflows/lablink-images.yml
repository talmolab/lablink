name: Build and Push Docker Images

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to run the workflow against"
        required: true
        default: "test"
        type: choice
        options:
          - test
          - prod
      allocator_version:
        description: "Allocator package version (REQUIRED for prod, leave empty for test)"
        required: false
        type: string
      client_version:
        description: "Client package version (REQUIRED for prod, leave empty for test)"
        required: false
        type: string
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - "packages/**"
      - ".github/workflows/lablink-images.yml"
  push:
    branches:
      - main
      - test
    paths:
      - "packages/**"
      - ".github/workflows/lablink-images.yml"

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - image-name: lablink-allocator-image
            dockerfile-path: ./packages/allocator/Dockerfile
            context: ./packages/allocator
          - image-name: lablink-client-base-image
            dockerfile-path: ./packages/client/Dockerfile
            context: ./packages/client
    outputs:
      git_sha: ${{ steps.get_sha.outputs.sha }}
      sanitized_platform: ${{ steps.sanitize_platform.outputs.sanitized_platform }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate production build requirements
        if: github.event_name == 'workflow_dispatch' && inputs.environment == 'prod'
        run: |
          if [ -z "${{ inputs.allocator_version }}" ] || [ -z "${{ inputs.client_version }}" ]; then
            echo "❌ ERROR: Production builds require both allocator_version and client_version"
            echo "Please provide versions or use environment=test for development builds"
            exit 1
          fi

      - name: Select Dockerfile and build args
        id: docker_config
        run: |
          # Determine if this is a dev build (use Dockerfile.dev with local code)
          # or prod build (use Dockerfile with PyPI package)
          if [ "${{ github.event_name }}" == "pull_request" ] || [ "${{ github.ref_name }}" == "test" ] || [ "${{ github.ref_name }}" == "main" ] || [ "${{ inputs.environment }}" == "test" ]; then
            # Dev builds: PR, push to test/main, or manual test
            echo "dockerfile_suffix=.dev" >> $GITHUB_OUTPUT
            echo "build_args=" >> $GITHUB_OUTPUT
            echo "is_dev=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ inputs.environment }}" == "prod" ]; then
            # Production build: manual dispatch with prod environment
            # Determine version based on image type
            if [ "${{ matrix.image-name }}" == "lablink-allocator-image" ]; then
              VERSION="${{ inputs.allocator_version }}"
            elif [ "${{ matrix.image-name }}" == "lablink-client-base-image" ]; then
              VERSION="${{ inputs.client_version }}"
            fi

            # Version should always be provided due to validation step
            if [ -n "$VERSION" ]; then
              echo "dockerfile_suffix=" >> $GITHUB_OUTPUT
              echo "build_args=PACKAGE_VERSION=${VERSION}" >> $GITHUB_OUTPUT
              echo "is_dev=false" >> $GITHUB_OUTPUT
            else
              echo "ERROR: Production build without version (validation should have caught this)"
              exit 1
            fi
          else
            # Fallback for unexpected trigger types - default to dev build for safety
            echo "WARNING: Unexpected trigger type, defaulting to dev build"
            echo "dockerfile_suffix=.dev" >> $GITHUB_OUTPUT
            echo "build_args=" >> $GITHUB_OUTPUT
            echo "is_dev=true" >> $GITHUB_OUTPUT
          fi

      - name: Set environment suffix
        id: set_env_suffix
        run: |
          # Add -test suffix for all dev builds (not for manual prod builds)
          if [ "${{ inputs.environment }}" == "prod" ]; then
            # Manual prod build - no suffix
            echo "env_suffix=" >> $GITHUB_OUTPUT
          elif [ "${{ github.event_name }}" == "pull_request" ] || [ "${{ github.ref_name }}" == "test" ] || [ "${{ github.ref_name }}" == "main" ] || [ "${{ inputs.environment }}" == "test" ]; then
            # All other cases - dev builds with -test suffix
            echo "env_suffix=-test" >> $GITHUB_OUTPUT
          else
            # Fallback - no suffix
            echo "env_suffix=" >> $GITHUB_OUTPUT
          fi

      - name: Get Git SHA
        id: get_sha
        run: echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Debug Git SHA
        run: echo "Git SHA ${{ steps.get_sha.outputs.sha }}"

      - name: Sanitize platform name
        id: sanitize_platform
        run: |
          sanitized_platform="linux/amd64"
          sanitized_platform="${sanitized_platform/\//-}"
          echo "sanitized_platform=$sanitized_platform" >> $GITHUB_OUTPUT

      - name: Generate tags
        id: generate_tags
        run: |
          REPO_OWNER="${{ github.repository_owner }}"
          PLATFORM="${{ steps.sanitize_platform.outputs.sanitized_platform }}"
          SHA="${{ steps.get_sha.outputs.sha }}"
          ENV_SUFFIX="${{ steps.set_env_suffix.outputs.env_suffix }}"

          # Extract package version if available from workflow_dispatch
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            # Use image-specific version
            if [ "${{ matrix.image-name }}" == "lablink-allocator-image" ]; then
              PKG_VERSION="${{ inputs.allocator_version }}"
            elif [ "${{ matrix.image-name }}" == "lablink-client-base-image" ]; then
              PKG_VERSION="${{ inputs.client_version }}"
            fi
          else
            PKG_VERSION=""
          fi

          if [ "${{ matrix.image-name }}" == "lablink-allocator-image" ]; then
            tags="ghcr.io/$REPO_OWNER/lablink-allocator-image:$PLATFORM$ENV_SUFFIX,ghcr.io/$REPO_OWNER/lablink-allocator-image:$PLATFORM-$SHA$ENV_SUFFIX,ghcr.io/$REPO_OWNER/lablink-allocator-image:$PLATFORM-latest$ENV_SUFFIX,ghcr.io/$REPO_OWNER/lablink-allocator-image:$PLATFORM-terraform-1.4.6$ENV_SUFFIX,ghcr.io/$REPO_OWNER/lablink-allocator-image:$PLATFORM-postgres-15$ENV_SUFFIX"

            # Add package version tag if available
            if [ -n "$PKG_VERSION" ]; then
              tags="$tags,ghcr.io/$REPO_OWNER/lablink-allocator-image:$PKG_VERSION,ghcr.io/$REPO_OWNER/lablink-allocator-image:$PLATFORM-$PKG_VERSION"
            fi

            if [ -z "$ENV_SUFFIX" ]; then
              tags="$tags,ghcr.io/$REPO_OWNER/lablink-allocator-image:latest"
            fi
            echo "tags=$tags" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.image-name }}" == "lablink-client-base-image" ]; then
            tags="ghcr.io/$REPO_OWNER/lablink-client-base-image:$PLATFORM$ENV_SUFFIX,ghcr.io/$REPO_OWNER/lablink-client-base-image:$PLATFORM-latest$ENV_SUFFIX,ghcr.io/$REPO_OWNER/lablink-client-base-image:$PLATFORM-nvidia-cuda-12.8.1-cudnn8-devel-ubuntu22.04$ENV_SUFFIX,ghcr.io/$REPO_OWNER/lablink-client-base-image:$PLATFORM-$SHA$ENV_SUFFIX,ghcr.io/$REPO_OWNER/lablink-client-base-image:$PLATFORM-ubuntu22.04-nvm-0.40.2-uv-0.6.8-miniforge3-24.11.3$ENV_SUFFIX"

            # Add package version tag if available
            if [ -n "$PKG_VERSION" ]; then
              tags="$tags,ghcr.io/$REPO_OWNER/lablink-client-base-image:$PKG_VERSION,ghcr.io/$REPO_OWNER/lablink-client-base-image:$PLATFORM-$PKG_VERSION"
            fi

            if [ -z "$ENV_SUFFIX" ]; then
              tags="$tags,ghcr.io/$REPO_OWNER/lablink-client-base-image:latest"
            fi
            echo "tags=$tags" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver: docker-container

      - name: Authenticate to GitHub Container Registry
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile-path }}${{ steps.docker_config.outputs.dockerfile_suffix }}
          platforms: linux/amd64
          push: true
          tags: ${{ steps.generate_tags.outputs.tags }}
          build-args: ${{ steps.docker_config.outputs.build_args }}

      - name: Build Summary
        run: |
          echo "✅ Docker image built successfully!"
          echo "Image tags: ${{ steps.generate_tags.outputs.tags }}"
          echo "Dockerfile: ${{ matrix.dockerfile-path }}${{ steps.docker_config.outputs.dockerfile_suffix }}"
          if [ -n "${{ steps.docker_config.outputs.build_args }}" ]; then
            echo "Build args: ${{ steps.docker_config.outputs.build_args }}"
          fi

  verify-allocator:
    name: Verify Allocator Image
    runs-on: ubuntu-latest
    needs: build
    if: contains(needs.build.result, 'success')
    steps:
      - name: Authenticate to GitHub Container Registry
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Determine image tag
        id: get_tag
        run: |
          REPO_OWNER="${{ github.repository_owner }}"
          SHA="${{ needs.build.outputs.git_sha }}"
          PLATFORM="${{ needs.build.outputs.sanitized_platform }}"

          # Determine ENV_SUFFIX (matches build job logic)
          if [ "${{ inputs.environment }}" == "prod" ]; then
            ENV_SUFFIX=""
          elif [ "${{ github.event_name }}" == "pull_request" ] || [ "${{ github.ref_name }}" == "test" ] || [ "${{ github.ref_name }}" == "main" ] || [ "${{ inputs.environment }}" == "test" ]; then
            ENV_SUFFIX="-test"
          else
            ENV_SUFFIX=""
          fi

          # Use SHA tag for exact image match (prevents race conditions)
          TAG="${PLATFORM}-${SHA}${ENV_SUFFIX}"

          IMAGE="ghcr.io/$REPO_OWNER/lablink-allocator-image:$TAG"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

      - name: Pull allocator image
        run: docker pull ${{ steps.get_tag.outputs.image }}

      - name: Verify allocator console scripts
        run: |
          echo "Testing allocator console scripts..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c "source /app/.venv/bin/activate && echo \"lablink-allocator:\" && which lablink-allocator && echo \"generate-init-sql:\" && which generate-init-sql && echo \"Allocator console scripts verified\""

      - name: Verify allocator package imports
        run: |
          echo "Testing allocator package imports..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /app/.venv/bin/activate && python -c "
          import warnings
          warnings.filterwarnings(\"ignore\")
          import logging
          logging.basicConfig(level=logging.ERROR)
          print(\"Importing allocator packages:\")
          from lablink_allocator_service.main import main
          print(\"  - main.main imported\")
          from lablink_allocator_service.database import PostgresqlDatabase
          print(\"  - database.PostgresqlDatabase imported\")
          from lablink_allocator_service.get_config import get_config
          print(\"  - get_config.get_config imported\")
          print(\"Allocator imports verified\")
          "'

      - name: Verify allocator dev dependencies (dev images only)
        if: github.event_name == 'pull_request' || github.ref_name == 'test' || github.ref_name == 'main' || inputs.environment == 'test'
        run: |
          echo "Testing allocator dev dependencies..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /app/.venv/bin/activate && python -c "
          print(\"Checking allocator dev dependencies:\")
          import pytest; print(\"  - pytest version:\", pytest.__version__)
          import ruff; print(\"  - ruff available\")
          print(\"Dev dependencies verified\")
          "'

      - name: Run allocator tests (dev images only)
        if: github.event_name == 'pull_request' || github.ref_name == 'test' || github.ref_name == 'main' || inputs.environment == 'test'
        run: |
          echo "Running allocator pytest tests..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'cd /app/lablink-allocator && source /app/.venv/bin/activate && pytest tests --ignore=tests/terraform -v --tb=short'

      - name: Verify allocator entry points are importable
        run: |
          echo "Testing allocator console script entry points can be imported..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /app/.venv/bin/activate && python -c "
          from lablink_allocator_service.main import main as allocator_main
          from lablink_allocator_service.generate_init_sql import main as generate_sql_main
          assert callable(allocator_main), \"allocator main() is not callable\"
          assert callable(generate_sql_main), \"generate_init_sql main() is not callable\"
          print(\"✓ All entry points are importable and callable\")
          "'

      - name: Execute allocator console scripts
        run: |
          echo "Testing allocator console script execution..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /app/.venv/bin/activate && generate-init-sql 2>/dev/null && test -f /app/init.sql && wc -l /app/init.sql && echo "generate-init-sql executed successfully"'
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /app/.venv/bin/activate && timeout 2 lablink-allocator > /tmp/allocator_output.txt 2>&1 || true && test -s /tmp/allocator_output.txt && echo "lablink-allocator entry point executed"'

  verify-client:
    name: Verify Client Image
    runs-on: ubuntu-latest
    needs: build
    if: contains(needs.build.result, 'success')
    steps:
      - name: Authenticate to GitHub Container Registry
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Determine image tag
        id: get_tag
        run: |
          REPO_OWNER="${{ github.repository_owner }}"
          SHA="${{ needs.build.outputs.git_sha }}"
          PLATFORM="${{ needs.build.outputs.sanitized_platform }}"

          # Determine ENV_SUFFIX (matches build job logic)
          if [ "${{ inputs.environment }}" == "prod" ]; then
            ENV_SUFFIX=""
          elif [ "${{ github.event_name }}" == "pull_request" ] || [ "${{ github.ref_name }}" == "test" ] || [ "${{ github.ref_name }}" == "main" ] || [ "${{ inputs.environment }}" == "test" ]; then
            ENV_SUFFIX="-test"
          else
            ENV_SUFFIX=""
          fi

          # Use SHA tag for exact image match (prevents race conditions)
          TAG="${PLATFORM}-${SHA}${ENV_SUFFIX}"

          IMAGE="ghcr.io/$REPO_OWNER/lablink-client-base-image:$TAG"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT

      - name: Pull client image
        run: docker pull ${{ steps.get_tag.outputs.image }}

      - name: Verify client console scripts exist
        run: |
          echo "Testing client console scripts..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c "source /home/client/.venv/bin/activate && echo \"check_gpu:\" && which check_gpu && echo \"subscribe:\" && which subscribe && echo \"update_inuse_status:\" && which update_inuse_status && echo \"Client console scripts verified\""

      - name: Verify client package imports
        run: |
          echo "Testing client package imports..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /home/client/.venv/bin/activate && python -c "
          print(\"Importing client packages:\")
          from lablink_client_service.subscribe import main
          print(\"  - subscribe.main imported\")
          from lablink_client_service.check_gpu import main as check_main
          print(\"  - check_gpu.main imported\")
          from lablink_client_service.update_inuse_status import main as update_main
          print(\"  - update_inuse_status.main imported\")
          print(\"Client imports verified\")
          "'

      - name: Verify uv is available
        run: |
          echo "Testing uv availability..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c "which uv && echo \"uv version:\" && uv --version"

      - name: Verify client dev dependencies (dev images only)
        if: github.event_name == 'pull_request' || github.ref_name == 'test' || github.ref_name == 'main' || inputs.environment == 'test'
        run: |
          echo "Testing client dev dependencies..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /home/client/.venv/bin/activate && python -c "
          print(\"Checking client dev dependencies:\")
          import pytest; print(\"  - pytest version:\", pytest.__version__)
          import ruff; print(\"  - ruff available\")
          print(\"Dev dependencies verified\")
          "'

      - name: Run client tests (dev images only)
        if: github.event_name == 'pull_request' || github.ref_name == 'test' || github.ref_name == 'main' || inputs.environment == 'test'
        run: |
          echo "Running client pytest tests..."
          docker run --rm --user client ${{ steps.get_tag.outputs.image }} bash -c 'cd /home/client/lablink-client && source /home/client/.venv/bin/activate && pytest tests -v --tb=short'

      - name: Verify client entry points are importable
        run: |
          echo "Testing client console script entry points can be imported..."
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /home/client/.venv/bin/activate && python -c "
          from lablink_client_service.check_gpu import main as check_gpu_main
          from lablink_client_service.subscribe import main as subscribe_main
          from lablink_client_service.update_inuse_status import main as update_main
          assert callable(check_gpu_main), \"check_gpu main() is not callable\"
          assert callable(subscribe_main), \"subscribe main() is not callable\"
          assert callable(update_main), \"update_inuse_status main() is not callable\"
          print(\"✓ All entry points are importable and callable\")
          "'

      - name: Execute client console scripts
        run: |
          echo "Testing client console script execution..."
          # Test that scripts execute (will fail without allocator, but should attempt to run)
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /home/client/.venv/bin/activate && timeout 2 check_gpu > /tmp/check_gpu_output.txt 2>&1 || true && test -s /tmp/check_gpu_output.txt && echo "check_gpu entry point executed"'
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /home/client/.venv/bin/activate && timeout 2 subscribe > /tmp/subscribe_output.txt 2>&1 || true && test -s /tmp/subscribe_output.txt && echo "subscribe entry point executed"'
          docker run --rm ${{ steps.get_tag.outputs.image }} bash -c 'source /home/client/.venv/bin/activate && timeout 2 update_inuse_status > /tmp/update_output.txt 2>&1 || true && test -s /tmp/update_output.txt && echo "update_inuse_status entry point executed"'

      - name: Verify custom-startup.sh transfer
        run: |
          echo "Testing custom-startup.sh execution..."
          CUSTOM_STARTUP_SCRIPT_CONTENT=$(cat <<'EOF'
          #!/bin/bash
          echo "CUSTOM_STARTUP_SCRIPT_EXECUTED_SUCCESSFULLY"
          sudo apt-get update -y
          sudo apt-get install -y jq
          echo "JQ_VERSION: $(jq --version)"
          EOF
          )
          TEMP_SCRIPT_FILE=$(mktemp)
          echo "$CUSTOM_STARTUP_SCRIPT_CONTENT" > "$TEMP_SCRIPT_FILE"
          chmod +x "$TEMP_SCRIPT_FILE"

          # Run the client container, mounting the temporary custom-startup.sh
          # The client's start.sh expects custom-startup.sh at /docker_scripts/custom-startup.sh
          # We override the entrypoint to ensure start.sh is executed, which in turn runs custom-startup.sh
          OUTPUT=$(docker run --rm -u client -v "$TEMP_SCRIPT_FILE":/docker_scripts/custom-startup.sh:ro ${{ steps.get_tag.outputs.image }} bash -c "source /home/client/.venv/bin/activate && sudo bash /docker_scripts/custom-startup.sh")

          echo "Docker container output:"
          echo "$OUTPUT"

          if echo "$OUTPUT" | grep -q "CUSTOM_STARTUP_SCRIPT_EXECUTED_SUCCESSFULLY" && 
             echo "$OUTPUT" | grep -q "JQ_VERSION: jq-"; then
            echo "✓ custom-startup.sh executed successfully and jq installed!"
          else
            echo "custom-startup.sh did NOT execute or jq was not installed."
            exit 1
          fi
          rm "$TEMP_SCRIPT_FILE"
